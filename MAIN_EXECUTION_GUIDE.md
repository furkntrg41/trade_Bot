# ðŸš€ TRADING BOT EXECUTION GUIDE

## Overview

Your production trading bot is now fully assembled with:
- âœ… **ExecutionEngine v2.0** - Military-grade safety protocols
- âœ… **Market Scanner** - 10 validated pairs from live data
- âœ… **Main Entry Point** - Async orchestration engine

## Files Structure

```
.
â”œâ”€â”€ main.py                              â† START HERE (entry point)
â”œâ”€â”€ config.json                          â† API keys & settings
â”œâ”€â”€ pairs_config.json                    â† Generated by scanner (10 pairs)
â”œâ”€â”€ quant_arbitrage/
â”‚   â”œâ”€â”€ execution_engine.py              â† Trade execution (1089 lines, 5 safety protocols)
â”‚   â”œâ”€â”€ execution_engine.py.backup       â† Original (backed up)
â”‚   â”œâ”€â”€ signal_generator.py              â† Z-score signal generation
â”‚   â”œâ”€â”€ spread_calculator.py             â† Cointegration math
â”‚   â”œâ”€â”€ cointegration_analyzer.py        â† ADF/Engle-Granger tests
â”‚   â”œâ”€â”€ config.py                        â† Centralized configuration
â”‚   â”œâ”€â”€ websocket_provider.py            â† Binance WebSocket connector
â”‚   â””â”€â”€ main_bot.py                      â† Previous version (for reference)
â””â”€â”€ logs/
    â””â”€â”€ trading_bot.log                  â† Runtime logs
```

## Quick Start

### 1. **Verify Configuration Files**

```bash
# Check API keys are loaded (config.json)
cat config.json

# Verify pairs config has 10 valid pairs
cat pairs_config.json
```

Expected `pairs_config.json`:
```json
{
  "pairs": [
    {
      "pair_id": "1000CAT_1MBABYDOGE",
      "leg_a": "1000CAT/USDT",
      "leg_b": "1MBABYDOGE/USDT",
      "hedge_ratio": 0.7387,
      "z_score_threshold": 2.0,
      "stop_loss_z": 4.0,
      "half_life_candles": 5
    },
    ...
  ]
}
```

### 2. **Set Environment Variables**

```bash
# Option A: Export to environment
export BINANCE_API_KEY="your_api_key_here"
export BINANCE_API_SECRET="your_api_secret_here"
export TRADING_MODE="paper"      # or "live"
export DRY_RUN="true"             # or "false"

# Option B: Use .env file
# Create .env file with above variables
```

### 3. **Start the Trading Bot**

```bash
# Production start (async event loop)
python main.py

# With logging output
python main.py 2>&1 | tee trading_session.log
```

**Expected Output:**

```
2026-02-01 20:50:00 - __main__ - INFO - ðŸ¤– TradingBot initialized | Config: config.json | Pairs: pairs_config.json
2026-02-01 20:50:01 - __main__ - INFO - âœ… Config loaded | Mode: paper | Dry-run: true
2026-02-01 20:50:02 - __main__ - INFO - âœ… Pairs config loaded | Pairs: 10
2026-02-01 20:50:03 - __main__ - INFO - âœ… ExecutionEngine initialized
2026-02-01 20:50:04 - __main__ - INFO - âœ… SignalGenerator initialized | Pair: 1000CAT_1MBABYDOGE
...
2026-02-01 20:50:10 - __main__ - INFO - ðŸš€ TRADING BOT STARTED
2026-02-01 20:50:10 - __main__ - INFO - ðŸ”Œ Starting WebSocket monitoring...
2026-02-01 20:50:11 - __main__ - INFO - âœ… Monitoring started for 10 pairs
```

### 4. **Graceful Shutdown**

```bash
# Press Ctrl+C in the terminal
# Bot will:
# 1. Cancel all pending WebSocket subscriptions
# 2. Close all positions (if any)
# 3. Disconnect from exchange
# 4. Print final statistics
# 5. Save logs

# Output on shutdown:
ðŸ›‘ Initiating graceful shutdown...
âœ… ExecutionEngine disconnected
ðŸ“Š FINAL STATISTICS:
   Uptime: 3600.5s
   Signals processed: 45
   Trades executed: 12
   Success rate: 26.7%
âœ… Graceful shutdown complete
```

---

## Architecture Deep Dive

### Main Bot Orchestration Flow

```
main.py (Entry Point)
  â”‚
  â”œâ”€â”€â”€ TradingBot.__init__()
  â”‚     â””â”€ Load config paths
  â”‚     â””â”€ Initialize state
  â”‚
  â”œâ”€â”€â”€ TradingBot.load_configuration()
  â”‚     â”œâ”€ Load config.json (API keys)
  â”‚     â”œâ”€ Load pairs_config.json (10 pairs)
  â”‚     â””â”€ Parse PairConfig dataclasses
  â”‚
  â”œâ”€â”€â”€ TradingBot.initialize_components()
  â”‚     â”œâ”€ ExecutionEngine.connect()
  â”‚     â”‚   â””â”€ CCXT â†’ Binance Futures
  â”‚     â”‚   â””â”€ Fetch account balance
  â”‚     â”‚   â””â”€ Activate safety protocols
  â”‚     â”‚
  â”‚     â””â”€ For each pair:
  â”‚         â”œâ”€ SignalGenerator.__init__()
  â”‚         â”œâ”€ register_signal_callback()
  â”‚         â””â”€ Create execution handler
  â”‚
  â”œâ”€â”€â”€ TradingBot.start_monitoring() [MAIN LOOP]
  â”‚     â””â”€ For each pair (asyncio.gather):
  â”‚         â””â”€ _monitor_pair()
  â”‚             â””â”€ WebSocket.watch_ticker()
  â”‚                 â””â”€ On each tick:
  â”‚                     â”œâ”€ Update spread_calculator
  â”‚                     â”œâ”€ Calculate Z-score
  â”‚                     â”œâ”€ Check signal threshold
  â”‚                     â””â”€ If signal: execute_signal_callback()
  â”‚                         â””â”€ ExecutionEngine.execute_signal()
  â”‚                             â”œâ”€ SAFETY PROTOCOL 1: Concurrency Lock
  â”‚                             â”œâ”€ SAFETY PROTOCOL 2: Partial Fill Protection
  â”‚                             â”œâ”€ SAFETY PROTOCOL 3: Ghost Order Detection
  â”‚                             â”œâ”€ SAFETY PROTOCOL 4: Precision & Limits
  â”‚                             â””â”€ SAFETY PROTOCOL 5: Virtual Atomicity
  â”‚
  â””â”€â”€â”€ TradingBot.shutdown_gracefully()
        â”œâ”€ Cancel active tasks
        â”œâ”€ ExecutionEngine.disconnect()
        â”œâ”€ Close WebSocket streams
        â””â”€ Print statistics
```

### Key Components

#### 1. **ExecutionEngine** (1089 lines, production-hardened)

**Purpose:** Transform trading signals into real Binance Futures orders

**Safety Protocols:**
1. **Concurrency Lock** - `asyncio.Lock()` prevents race conditions
2. **Partial Fill Protection** - Dynamic hedge recalculation, abort if <10%
3. **Ghost Order Detection** - Timeout handling with `fetch_order()` verification
4. **Precision & Limits** - `amount_to_precision()` + min_notional validation
5. **Virtual Atomicity** - Emergency close on Leg B failure after Leg A fills

**Interface:**
```python
engine = ExecutionEngine(config=config)
connected = await engine.connect()           # Connect to Binance
executed = await engine.execute_signal(signal)  # Execute trade
await engine.disconnect()                   # Graceful close
```

#### 2. **SignalGenerator** (462 lines)

**Purpose:** Generate real-time trading signals from cointegrated pairs

**Process:**
1. Subscribe to WebSocket tickers
2. Calculate Z-score from spread
3. Compare against thresholds
4. Emit signal if threshold crossed

**Interface:**
```python
gen = SignalGenerator(pair_x="BTC", pair_y="ETH", hedge_ratio=0.065)
gen.register_signal_callback(async_callback)
await gen.start_streaming()  # Blocks until shutdown
```

#### 3. **Config Management**

**Loading Priority:**
1. Environment variables (BINANCE_API_KEY, BINANCE_API_SECRET, etc.)
2. config.json (fallback)
3. Defaults from Config dataclass

**Validation:**
```python
config = get_config(require_api_keys=True)  # For trading
config = get_config(require_api_keys=False) # For scanner
```

---

## Trading Pairs (Live Scan Results)

| # | Pair | Leg A | Leg B | Hedge Ratio | Half-Life | Status |
|---|------|-------|-------|-------------|-----------|--------|
| 1 | 1000CAT_1MBABYDOGE | 1000CAT/USDT | 1MBABYDOGE/USDT | 0.7387 | 5.3h | âœ… |
| 2 | 1INCH_AI | 1INCH/USDT | AI/USDT | 1.0802 | 4.0h | âœ… |
| 3 | 1000CAT_AIXBT | 1000CAT/USDT | AIXBT/USDT | 0.9429 | 8.5h | âœ… |
| 4 | 1MBABYDOGE_AEVO | 1MBABYDOGE/USDT | AEVO/USDT | 1.0480 | 5.0h | âœ… |
| 5 | AI_ALGO | AI/USDT | ALGO/USDT | 0.7077 | 5.1h | âœ… |
| 6 | AAVE_AI | AAVE/USDT | AI/USDT | 1.4681 | 5.7h | âœ… |
| 7 | AIXBT_ALICE | AIXBT/USDT | ALICE/USDT | 0.9236 | 9.5h | âœ… |
| 8 | 1MBABYDOGE_ADA | 1MBABYDOGE/USDT | ADA/USDT | 0.5160 | 17.2h | âœ… |
| 9 | ACE_ALT | ACE/USDT | ALT/USDT | 0.7740 | 5.2h | âœ… |
| 10 | 1000SATS_AEVO | 1000SATS/USDT | AEVO/USDT | 0.9661 | 6.2h | âœ… |

All pairs pass:
- âœ… ADF p-value < 0.05 (stationarity)
- âœ… Cointegration p-value < 0.05
- âœ… Half-life < 24h (mean reversion)

---

## Monitoring & Debugging

### 1. **Check Logs in Real-Time**

```bash
# Follow logs while bot is running
tail -f logs/trading_bot.log

# Or from another terminal
watch -n 1 tail -10 logs/trading_bot.log
```

### 2. **Key Log Markers**

```
âœ… = Success (connection, trade, etc.)
âš ï¸  = Warning (skipped trade, partial fill, etc.)
âŒ = Error (needs investigation)
ðŸ“¡ = Signal received
ðŸš€ = Signal executed
```

### 3. **Debug Mode**

Edit `main.py` line 43 to enable debug logging:
```python
logging.basicConfig(level=logging.DEBUG)  # More verbose
```

### 4. **Test Signal Generation**

Run scanner again to validate signal quality:
```bash
python run_scanner.py
```

---

## Common Issues & Solutions

### Issue 1: "API key required" Error

```
AssertionError: API key required
```

**Solution:**
```bash
export BINANCE_API_KEY="your_key"
export BINANCE_API_SECRET="your_secret"
python main.py
```

### Issue 2: "Connection Refused"

```
ConnectionError: Failed to connect to exchange
```

**Causes:**
- API key is invalid
- Rate limit exceeded
- Binance API is down

**Solution:**
```bash
# Check API key validity
python -c "import ccxt; ex = ccxt.binance({'apiKey': 'YOUR_KEY', 'secret': 'YOUR_SECRET'}); print(ex.fetch_balance())"

# Use testnet (in config.json)
"use_testnet": true
```

### Issue 3: "No Signals Generated"

**Possible Causes:**
1. Pairs are not cointegrated (market changed)
2. Z-score never exceeds threshold (need looser settings)
3. WebSocket connection dropped

**Solution:**
```bash
# Re-run scanner
python run_scanner.py

# Check WebSocket connection in logs
tail -f logs/trading_bot.log | grep -i "websocket"
```

### Issue 4: "Partial Fill Protection Triggered"

```
EXECUTION WARNING: Partial fill <10%, aborting trade
```

**Meaning:** Order filled less than 10% of requested amount

**Solution:**
- Reduce order size
- Use limit orders instead of market
- Check liquidity on the pair

---

## Production Checklist

Before running **LIVE** trading:

- [ ] Verify API keys are correct
- [ ] Test on **PAPER** mode first (`TRADING_MODE="paper"`)
- [ ] Confirm DRY_RUN is enabled (`DRY_RUN="true"`)
- [ ] Check account has sufficient balance
- [ ] Review log files for errors
- [ ] Test signal generation with one pair
- [ ] Verify execution callbacks are working
- [ ] Test graceful shutdown (Ctrl+C)
- [ ] Set up monitoring/alerting
- [ ] Start with small position sizes

### To Enable Live Trading:

```bash
export TRADING_MODE="live"
export DRY_RUN="false"
python main.py
```

---

## Performance Optimization

### 1. **Reduce WebSocket Latency**

In `main.py`, monitor network latency:
```python
logger.info(f"WebSocket latency: {datetime.utcnow() - tick_time}ms")
```

### 2. **Optimize SignalGenerator Lookback**

In `config.json`:
```json
"signal": {
  "lookback_bars": 50,    # â† Reduce for faster updates
  "entry_threshold": 2.0  # â† Higher = fewer signals
}
```

### 3. **Parallel Pair Processing**

Already optimized with `asyncio.gather()` in `start_monitoring()`

---

## Next Steps

### After First Successful Run:

1. âœ… **Monitor Signals** - Check for false positives
2. âœ… **Validate Fills** - Confirm spreads are closing
3. âœ… **Tune Thresholds** - Adjust Z-score entry/exit levels
4. âœ… **Add Risk Limits** - Implement position size limits
5. âœ… **Enable Notifications** - Slack/Email on trades

---

## Support & Debugging

**View Complete Execution Engine Code:**
```bash
cat quant_arbitrage/execution_engine.py | head -200
```

**View Current Configuration:**
```bash
python -c "from quant_arbitrage import get_config; print(get_config())"
```

**Run Tests:**
```bash
cd tests/
python -m pytest execution_engine_advanced_test.py -v
```

---

**ðŸŽ¯ You're ready! Execute:**

```bash
python main.py
```

**Happy trading! ðŸš€**
